package component

import (
	"context"
	"fmt"
)

type PopoverPosition int

const (
	PopoverPositionBottom PopoverPosition = iota
	PopoverPositionBottomStart
	PopoverPositionBottomEnd
	PopoverPositionTop
	PopoverPositionTopStart
	PopoverPositionTopEnd
	PopoverPositionLeft
	PopoverPositionLeftStart
	PopoverPositionLeftEnd
	PopoverPositionRight
	PopoverPositionRightStart
	PopoverPositionRightEnd
)

// Popover shows a popup on click.
//
// NOTE: the panel has fixed rounding for now.
// NOTE: could add transitions when popup shows.
type Popover struct {
	// ButtonChildren are placed inside the button that triggers the
	// popover. A nil value will default to [Button].
	ButtonChildren Component

	// PanelChildren are placed inside the popover panel. A nil value
	// will default to [PanelWindow].
	PanelChildren Component

	PanelPosition PopoverPosition

	// PanelOffset is offset in pixels.
	PanelOffset int
}

templ (m Popover) ToTempl(ctx context.Context) {
	<div
		x-id="['popover-button']"

		x-data="{ open: false }"

		@keydown.escape.prevent.stop="
			open = false;
			$refs.button.focus();
		"

		@focusin.window="
			if (! $refs.panel.contains($event.target)) {
				open = false;
			}
		"

		class="relative"
	>
		<button
			type="button"

			x-ref="button"

			@click="
				if (open) {
					open = false;
				} else {
					$refs.button.focus();
					open = true;
				}
			"

			:aria-controls="$id('popover-button')"

			:aria-expanded="open"

			class="relative rounded-lg transition cursor-pointer dark:hover:bg-gray-100/5 dark:active:bg-gray-100/10 hover:bg-gray-900/5 focus-visible:inset-ring-blue-500/50 focus-visible:inset-ring-2 focus-visible:outline-0 active:bg-gray-900/10"

			:class="open && 'bg-gray-900/5 dark:bg-gray-100/5'"
		>
			if m.ButtonChildren != nil {
				@m.ButtonChildren.ToTempl(ctx)
			} else {
				@Button{}.ToTempl(ctx)
			}
		</button>
		<template x-if="true">
			// NOTE: rounding is fixed
			<div
				x-ref="panel"

				x-show="open"

				@click.outside="
					if (open) {
						open = false;
						$refs.button.focus();
					}
				"

				:id="$id('popover-button')"

				class="z-10 rounded-2xl"

				{ generateXAnchorAttrKey(m.PanelPosition, m.PanelOffset)... }
			>
				if m.PanelChildren != nil {
					@m.PanelChildren.ToTempl(ctx)
				} else {
					@PanelWindow{}.ToTempl(ctx)
				}
			</div>
		</template>
	</div>
}

func generateXAnchorAttrKey(position PopoverPosition, offset int) templ.Attributes {
	var pp string
	switch position {
	case PopoverPositionBottom:
		pp = "bottom"
	case PopoverPositionBottomEnd:
		pp = "bottom-end"
	case PopoverPositionBottomStart:
		pp = "bottom-start"
	case PopoverPositionTop:
		pp = "top"
	case PopoverPositionTopEnd:
		pp = "top-end"
	case PopoverPositionTopStart:
		pp = "top-start"
	case PopoverPositionLeft:
		pp = "left"
	case PopoverPositionLeftEnd:
		pp = "left-end"
	case PopoverPositionLeftStart:
		pp = "left-start"
	case PopoverPositionRight:
		pp = "right"
	case PopoverPositionRightEnd:
		pp = "right-end"
	case PopoverPositionRightStart:
		pp = "right-start"
	}

	return templ.Attributes{
		fmt.Sprintf("x-anchor.%s.offset.%d", pp, offset): "$refs.button",
	}
}
