package component

import (
	"context"
)

// Drawer triggers a drawer panel on click.
type Drawer struct {
	// ButtonChildren are placed inside the button that triggers the
	// drawer. A nil value will default to [Button].
	ButtonChildren Component

	// PanelChildren are placed on the right side, in a floating layer.
	// A nil value indicates no children.
	PanelChildren Component
}

templ (m Drawer) ToTempl(ctx context.Context) {
	<div
		x-id="['drawer-button']"

		x-data="{ open: false }"

		@keydown.escape.window="open = false"

		class="relative"
	>
		<button
			type="button"

			x-ref="button"

			@click="open = true"

			class="relative cursor-pointer rounded-lg transition dark:hover:bg-gray-100/5 dark:active:bg-gray-100/20 hover:bg-gray-900/5 active:bg-gray-900/20"

			:class="open && 'bg-gray-900/5 dark:bg-gray-100/5'"
		>
			if m.ButtonChildren != nil {
				@m.ButtonChildren.ToTempl(ctx)
			} else {
				@Button{}.ToTempl(ctx)
			}
		</button>
		<template x-if="true">
			<div
				role="dialog"

				x-ref="panel"

				x-show="open"

				x-trap.inert.noscroll="open"

				aria-modal="true"

				@click.stop

				:id="$id('drawer-button')"

				x-transition.opacity

				class="fixed inset-0 flex justify-end z-30 bg-gray-900/20"
			>
				<div
					x-show="open"

					x-transition

					class="bg-gray-50 shadow w-lg h-screen overflow-y-auto md:rounded-l-2xl dark:bg-gray-950"
				>
					if m.PanelChildren != nil {
						@m.PanelChildren.ToTempl(ctx)
					}
				</div>
			</div>
		</template>
	</div>
}

func NewDrawerExitButton() Component {
	return ComponentFunc(drawerExitButton)
}

templ drawerExitButton(ctx context.Context) {
	<button
		type="button"

		x-ref="exit"

		@click="open = false"

		class="cursor-pointer size-9 rounded-lg flex items-center justify-center bg-gray-900/5 dark:bg-gray-100/5"
	>
		@WindowCloseIcon.ToTempl(ctx)
	</button>
}
