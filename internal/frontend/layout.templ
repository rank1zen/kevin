package frontend

import (
	"context"
	"fmt"
	"github.com/rank1zen/kevin/internal"
	"github.com/rank1zen/kevin/internal/riot"
	"io"
	"time"
)

type HeaderLayout struct {
	StartChildren templ.Component

	CenterChildren templ.Component

	EndChildren templ.Component
}

templ (m HeaderLayout) build() {
	<div class="flex w-full h-13 gap-x-2 justify-between items-center px-2">
		if m.StartChildren != nil {
			<div>
				@m.StartChildren
			</div>
		}
		if m.CenterChildren != nil {
			<div class="flex-1">
				@m.CenterChildren
			</div>
		}
		if m.EndChildren != nil {
			<div>
				@m.EndChildren
			</div>
		}
	</div>
}

func (m HeaderLayout) Render(ctx context.Context, w io.Writer) error {
	return m.build().Render(ctx, w)
}

type PageHeaderLayout struct {
	Region riot.Region
}

templ (m PageHeaderLayout) buildHeaderStart() {
	<div class="flex gap-2">
		<div class="size-9 transition flex items-center justify-center rounded-lg hover:bg-gray-900/5 dark:hover:bg-gray-100/5">
			<span>K</span>
		</div>
	</div>
}

templ (m PageHeaderLayout) buildHeaderCenter() {
	<div class="flex gap-2 justify-center">
		@RegionPopover{Region: m.Region}
		@SummonerSearchBar{}
	</div>
}

templ (m PageHeaderLayout) buildHeaderEnd() {
	<div class="flex gap-2">
		@MenuPopover{}
	</div>
}

func (m PageHeaderLayout) Render(ctx context.Context, w io.Writer) error {
	c := HeaderLayout{
		StartChildren:  m.buildHeaderStart(),
		CenterChildren: m.buildHeaderCenter(),
		EndChildren:    m.buildHeaderEnd(),
	}

	return c.Render(ctx, w)
}

type ModalHeaderLayout struct {
}

templ (m ModalHeaderLayout) buildHeaderEnd() {
	<div class="flex h-13 px-2 gap-x-2 items-center"></div>
}

func (m ModalHeaderLayout) Render(ctx context.Context, w io.Writer) error {
	header := HeaderLayout{
		EndChildren: nil,
	}

	return header.Render(ctx, w)
}

type MenuItemLayout struct {
	Label string

	SubLabel string
}

templ (m MenuItemLayout) build() {
	<div class="flex flex-item h-7 items-center justify-between px-3 gap-3">
		<span class="text-sm text-gray-900/90 dark:text-gray-100/90  whitespace-nowrap">{ m.Label }</span>
		<span class="text-sm text-gray-500/90 whitespace-nowrap">{ m.SubLabel }</span>
	</div>
}

func (m MenuItemLayout) Render(ctx context.Context, w io.Writer) error {
	return m.build().Render(ctx, w)
}

// MatchHistoryRowLayout displays a match in a summoner's match history.
type MatchHistoryRowLayout struct {
	MatchID string

	ChampionWidget ChampionWidget

	KDAWidget KDAWidget

	CSWidget CSWidget

	RuneWidget RuneWidget

	ItemWidget ItemWidget

	// RankChange is the rank after the match. A nil value means the store
	// did not record a rank after the match.
	RankChange *internal.RankDetail

	// LPChange is the lp change after the match. TODO: A nil value means ...
	LPChange *int

	Win bool
}

templ (m MatchHistoryRowLayout) buildRankChangeWidget() {
	<div class="h-9">
		if m.RankChange != nil {
			@RankWidget{Rank: m.RankChange, Size: TextSizeXS}
		} else {
			<div class="text-sm font-semibold text-gray-900/90 dark:text-gray-100/90">
				Unknown
			</div>
		}
		if m.Win {
			<div class="flex justify-end">
				<div class="text-xs bg-green-500/80 text-white px-1 rounded">
					if m.LPChange != nil {
						{ fmt.Sprintf("WIN %+d", m.LPChange) }
					} else {
						{ fmt.Sprintf("WIN +??") }
					}
				</div>
			</div>
		} else {
			<div class="flex justify-end">
				<div class="text-xs bg-red-500/80 text-white px-1 rounded">
					if m.LPChange != nil {
						{ fmt.Sprintf("LOSS %+d", m.LPChange) }
					} else {
						{ fmt.Sprintf("LOSS +??") }
					}
				</div>
			</div>
		}
	</div>
}

templ (m MatchHistoryRowLayout) build() {
	<div class="px-4 py-3 overflow-auto">
		<div class="flex justify-between items-center gap-x-2">
			<div class="flex gap-x-2">
				@m.ChampionWidget
				@m.KDAWidget
				@m.CSWidget
			</div>
			<div class="flex gap-x-2">
				@m.buildRankChangeWidget()
			</div>
		</div>
		<div class="flex justify-between items-center gap-x-2 mt-1">
			<div class="flex gap-x-2">
				@m.RuneWidget
			</div>
			<div class="flex gap-x-2">
				@m.ItemWidget
			</div>
		</div>
	</div>
}

func (m MatchHistoryRowLayout) Render(ctx context.Context, w io.Writer) error {
	return m.build().Render(ctx, w)
}

// LiveMatchRowLayout displays a participant in an on-going match.
type LiveMatchRowLayout struct {
	MatchID string

	ChampionWidget ChampionWidget

	RuneWidget RuneWidget

	TeamID int

	PUUID riot.PUUID

	Name, Tag string

	Rank *internal.RankDetail
}

templ (m LiveMatchRowLayout) build() {
	<div class="flex h-15 gap-x-4 px-4 justify-between items-center">
		<div class="flex gap-x-4">
			@m.ChampionWidget
			<div class="flex-1 min-w-0 h-9">
				<div class="text-sm text-semibold text-gray-900/90 dark:text-gray-100/90 whitespace-nowrap">
					{ m.Name + "#" + m.Tag }
				</div>
				@RankWidget{Rank: m.Rank, Size: TextSizeXS}
			</div>
		</div>
		<div class="flex gap-x-4">
			@m.RuneWidget
		</div>
	</div>
}

func (m LiveMatchRowLayout) Render(ctx context.Context, w io.Writer) error {
	return m.build().Render(ctx, w)
}

// ButtonLayout is a simple button layout.
type ButtonLayout struct {
	// IconPath is the icon on the button. If empty, no icon is used.
	Icon Icon

	// Label is the text on the button. If empty, no label is used.
	Label string
}

templ (m ButtonLayout) build() {
	if m.Label != "" {
		<div class="flex flex-none h-9 w-32 gap-2 items-center justify-center">
			if m.Icon != nil {
				@m.Icon
			}
			<span class="whitespace-nowrap font-bold text-sm text-gray-900/90 dark:text-gray-100/90">
				{ m.Label }
			</span>
		</div>
	} else {
		<div class="flex flex-none size-9 items-center justify-center">
			if m.Icon != nil {
				@m.Icon
			}
		</div>
	}
}

func (m ButtonLayout) Render(ctx context.Context, w io.Writer) error {
	return m.build().Render(ctx, w)
}

type ThinButtonLayout struct {
	// IconPath is the icon on the button. If empty, no icon is used.
	Icon Icon
}

templ (m ThinButtonLayout) build() {
	<div class="flex flex-none w-6 h-9 items-center justify-center">
		@m.Icon
	</div>
}

func (m ThinButtonLayout) Render(ctx context.Context, w io.Writer) error {
	return m.build().Render(ctx, w)
}

// ChampionModalRowLayout displays a averaged champion stats over a series of
// games.
type ChampionModalRowLayout struct {
	ChampionWidget ChampionWidget

	GamesPlayed int

	Wins, Losses int

	WinRate float32

	KDAWidget KDAWidget

	CSWidget CSWidget

	// TODO: add LP gain for all matches.
}

templ (m ChampionModalRowLayout) buildWinRateWidget() {
	<div class="h-9 flex-1 min-w-0 whitespace-nowrap">
		<div class="text-sm font-semibold text-gray-900/90 dark:text-gray-100/90">
			{ fmt.Sprintf("%d Games, %d W %d L", m.Wins, m.Losses, m.GamesPlayed) }
		</div>
		<div class="text-xs text-gray-900/90 dark:text-gray-100/90">
			{ fmt.Sprintf("%.0f%%", m.WinRate*100) }
		</div>
	</div>
}

templ (m ChampionModalRowLayout) build() {
	<div class="flex px-4 gap-x-4 py-3 justify-between items-center">
		<div class="flex flex-1 min-w-0 gap-x-2">
			@m.ChampionWidget
			@m.buildWinRateWidget()
		</div>
		<div class="flex gap-x-2">
			@m.KDAWidget
			@m.CSWidget
		</div>
	</div>
}

func (m ChampionModalRowLayout) Render(ctx context.Context, w io.Writer) error {
	return m.build().Render(ctx, w)
}

type ChampionModalLayout struct {
	List ChampionModalList
}

templ (m ChampionModalLayout) build() {
	<div class="px-2 mt-3">
		@m.List
	</div>
}

templ (m ChampionModalLayout) buildHeaderStart() {
	<div class="flex gap-x-2">
	</div>
}

templ (m ChampionModalLayout) buildHeaderCenter() {
	<div class="flex justify-center items-center gap-x-2 h-9">
		<div class="text-sm font-bold">
			Past week
		</div>
	</div>
}

templ (m ChampionModalLayout) buildHeaderEnd() {
	<div class="flex gap-x-2">
		<div class="flex items-center justify-center size-9">
			@ExitModalButton{}
		</div>
	</div>
}

func (m ChampionModalLayout) Render(ctx context.Context, w io.Writer) error {
	layout := ModalLayout{
		HeaderChildren: HeaderLayout{
			StartChildren:  m.buildHeaderStart(),
			CenterChildren: m.buildHeaderCenter(),
			EndChildren:    m.buildHeaderEnd(),
		},

		Children: m.build(),
	}

	return layout.Render(ctx, w)
}

// ModalLayout is the layout used for modal windows.
type ModalLayout struct {
	// HeaderChildren are placed in the header. A nil value indicates no
	// header.
	HeaderChildren templ.Component

	// Children are placed in the main body. A nil value indicates an empty
	// page.
	Children templ.Component
}

templ (m ModalLayout) build() {
	if m.HeaderChildren != nil {
		<div>
			<div class="sticky">
				@m.HeaderChildren
			</div>
			<div>
				if m.Children != nil {
					@m.Children
				}
			</div>
		</div>
	} else {
		<div>
			if m.Children != nil {
				@m.Children
			}
		</div>
	}
}

func (m ModalLayout) Render(ctx context.Context, w io.Writer) error {
	return m.build().Render(ctx, w)
}

// LiveMatchModalWindow is a modal window for a live match.
type LiveMatchModalLayout struct {
	AverageRank *internal.RankDetail

	StartTime time.Time

	BlueSide, RedSide [5]LiveMatchRowLayout
}

templ (m LiveMatchModalLayout) makeHeaderContent() {
	<div class="flex items-center justify-between gap-2">
		<div class="flex">
			{ fmt.Sprintf("%v", m.StartTime) }
		</div>
		<div class="flex">
			Avg Rank Grandmaster // Avg Rank Grandmaster
		</div>
	</div>
}

templ (m LiveMatchModalLayout) buildChildren() {
	{{
		blueSide, redSide := []templ.Component{}, []templ.Component{}
		for i := range 5 {
			blueSide = append(blueSide, m.BlueSide[i])
			redSide = append(redSide, m.RedSide[i])
		}
	}}
	<div class="px-2">
		<div class="">
			<h2 class="font-bold text-base text-gray-900/90 dark:text-gray-100/90 mt-9">
				Blue Side
			</h2>
			<div class="mt-3">
				@List{Items: blueSide}
			</div>
			<h2 class="font-bold text-base text-gray-900/90 dark:text-gray-100/90 mt-9">
				Red Side
			</h2>
			<div class="mt-3">
				@List{Items: redSide}
			</div>
		</div>
	</div>
}

func (m LiveMatchModalLayout) Render(ctx context.Context, w io.Writer) error {
	window := ModalLayout{
		HeaderChildren: nil,
		Children:       m.buildChildren(),
	}

	return window.Render(ctx, w)
}

type NoLiveMatchModalWindow struct{}

templ (m NoLiveMatchModalWindow) makeHeaderContent() {
}

templ (m NoLiveMatchModalWindow) makeContent() {
	<div class="flex flex-col items-center justify-center">
		<span class="text-base">
			Currently not in live game
		</span>
	</div>
}

func (m NoLiveMatchModalWindow) Render(ctx context.Context, w io.Writer) error {
	modal := ModalLayout{
		HeaderChildren: m.makeHeaderContent(),
		Children:       m.makeContent(),
	}

	return modal.Render(ctx, w)
}
