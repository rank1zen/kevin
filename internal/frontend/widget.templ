package frontend

import (
	"context"
	"fmt"
	"github.com/rank1zen/kevin/internal"
	"github.com/rank1zen/kevin/internal/ddragon"
	"io"
	"path"
)

// ChampionWidget displays a champion icon and summoner spells.
type ChampionWidget struct {
	Champion int

	ChampionLevel int

	// .. if nil, summoner spells are not included.
	Summoners *[2]int
}

func (m ChampionWidget) generateSpriteBGPosition(id int) string {
	summ := ddragon.SummonerMap[id]
	x := summ.X / 48
	y := summ.Y / 48
	return fmt.Sprintf("bg-position-[-%dpx_-%dpx]", x*28, y*28)
}

func (m ChampionWidget) generateSpriteBG(id int) string {
	summ := ddragon.SummonerMap[id]
	p := path.Join("/static/sprite", "small_"+summ.Sprite)
	return fmt.Sprintf("bg-[url(%s)]", p)
}

templ (m ChampionWidget) makeSummonerAtIndex(i int) {
	{{ id := m.Summoners[i] }}
	<div class={ "rounded-lg", "size-7", m.generateSpriteBG(id), m.generateSpriteBGPosition(id), "bg-size-[280px_112px]" }></div>
}

templ (m ChampionWidget) buildChampionIcon() {
	{{ champion := ddragon.ChampionMap[m.Champion] }}
	{{ x := 3 * champion.X / 4 }}
	{{ y := 3 * champion.Y / 4 }}
	<img
		src={ path.Join("/static/sprite", "small_"+champion.Sprite) }
		class={ fmt.Sprintf("w-[%dpx] h-[%dpx] object-none object-[-%dpx_-%dpx] rounded", 36, 36, x, y) }
	/>
}

templ (m ChampionWidget) build() {
	{{
		champion := ddragon.ChampionMap[m.Champion]

		championTooltip := Tooltip{Tip: champion.Name, ButtonChildren: m.buildChampionIcon()}
	}}
	if m.Summoners != nil {
		<div class="flex flex-none items-center gap-1">
			@championTooltip
			<div class="flex p-1 gap-1 bg-gray-900/5 dark:bg-gray-100/5 rounded-lg">
				@Tooltip{ButtonChildren: m.makeSummonerAtIndex(0)}
				@Tooltip{ButtonChildren: m.makeSummonerAtIndex(1)}
			</div>
		</div>
	} else {
		@championTooltip
	}
}

func (m ChampionWidget) Render(ctx context.Context, w io.Writer) error {
	return m.build().Render(ctx, w)
}

// RuneWidget is displays match runes.
type RuneWidget struct {
	RunePage internal.RunePage
}

templ (m RuneWidget) buildFullRunPageView() {
	// TODO
}

templ (m RuneWidget) buildKeystone() {
	<div class="size-9">
		<img
			src={ path.Join("/static/", ddragon.RuneMap[m.RunePage.PrimaryKeystone].IconPath) }
			class="size-9"
		/>
	</div>
}

templ (m RuneWidget) buildSecondary() {
	<div class="h-9 w-6 flex items-center justify-center">
		<img
			src={ path.Join("/static/", ddragon.RuneMap[m.RunePage.SecondaryTree].IconPath) }
			class="size-4"
		/>
	</div>
}

templ (m RuneWidget) build() {
	{{
		keystone := ddragon.RuneMap[m.RunePage.PrimaryKeystone]
		secondaryTree := ddragon.RuneMap[m.RunePage.SecondaryTree]
	}}
	<div class="flex flex-none items-center h-9 bg-gray-900/5 dark:bg-gray-100/5 rounded-lg">
		@Tooltip{Tip: keystone.Name, ButtonChildren: m.buildKeystone(), ButtonStyle: 1}
		@Tooltip{Tip: secondaryTree.Name, ButtonChildren: m.buildSecondary(), ButtonStyle: 1}
		@Popover{ButtonChildren: ThinButton{IconPath: "down-small-symbolic.svg"}}
	</div>
}

func (m RuneWidget) Render(ctx context.Context, w io.Writer) error {
	return m.build().Render(ctx, w)
}

// ItemWidget displays an inventory of items.
type ItemWidget struct {
	Items [7]int
}

func (m ItemWidget) generateSpriteBGPosition(id int) string {
	item := ddragon.ItemsMap[id]
	x := item.X / 48
	y := item.Y / 48
	return fmt.Sprintf("bg-position-[-%dpx_-%dpx]", x*28, y*28)
}

func (m ItemWidget) generateSpriteBG(id int) string {
	item := ddragon.ItemsMap[id]
	p := path.Join("/static/sprite", "small_"+item.Sprite)
	return fmt.Sprintf("bg-[url(%s)]", p)
}

templ (m ItemWidget) makeItemAtIndex(i int) {
	{{ id := m.Items[i] }}
	if id == 0 {
		<div class="size-7 rounded bg-gray-900/5 dark:bg-gray-100/5"></div>
	} else {
		<button
			title={ ddragon.ItemsMap[id].Name }
			type="button"
			if i == 6 {
				class="size-7 shadow-xs shadow-gray-900/50 dark:shadow-gray-100/50 overflow-hidden cursor-pointer rounded-full"
			} else {
				class="size-7 shadow-xs shadow-gray-900/50 dark:shadow-gray-100/50 overflow-hidden cursor-pointer rounded"
			}
		>
			<div class={ "size-7", m.generateSpriteBG(id), m.generateSpriteBGPosition(id), "bg-size-[280px_280px]" }></div>
		</button>
	}
}

templ (m ItemWidget) build() {
	<div class="flex flex-none bg-gray-900/5 dark:bg-gray-100/5 rounded-lg">
		<div class="flex gap-1 p-1">
			for i := range 7 {
				@m.makeItemAtIndex(i)
			}
		</div>
		@Popover{ButtonChildren: ThinButton{IconPath: "down-small-symbolic.svg"}}
	</div>
}

func (m ItemWidget) Render(ctx context.Context, w io.Writer) error {
	return m.build().Render(ctx, w)
}

type KDAWidget struct {
	Kills, Deaths, Assists int
}

func (m KDAWidget) generateKillTextColor() string {
	if m.Kills < 3 {
		return "text-gray-900/90"
	} else if m.Kills < 6 {
		return "text-yelow-900/90"
	} else if m.Kills < 9 {
		return "text-yellow-800/90"
	} else {
		return "text-yellow-500/90"
	}
}

func (m KDAWidget) generateDeathTextColor() string {
	if m.Deaths < 3 {
		return "text-gray-400"
	} else if m.Deaths < 6 {
		return "text-red-200"
	} else if m.Deaths < 9 {
		return "text-red-300"
	} else {
		return "text-red-400"
	}
}

func (m KDAWidget) generateAssistTextColor() string {
	if m.Assists < 3 {
		return "text-gray-400"
	} else if m.Assists < 6 {
		return "text-cyan-200"
	} else if m.Assists < 9 {
		return "text-cyan-300"
	} else {
		return "text-cyan-400"
	}
}

templ (m KDAWidget) sep() {
	<span class="text-xs text-gray-200">
		/
	</span>
}

templ (m KDAWidget) build() {
	<div class="flex flex-none items-center">
		<div class="flex justify-center w-6">
			<span class={ m.generateKillTextColor() }>
				{ fmt.Sprintf("%d", m.Kills) }
			</span>
		</div>
		@m.sep()
		<div class="flex justify-center w-6">
			<span class="text-red-900/90">
				{ fmt.Sprintf("%d", m.Deaths) }
			</span>
		</div>
		@m.sep()
		<div class="flex justify-center w-6">
			<span class="text-gray-900/90">
				{ fmt.Sprintf("%d", m.Assists) }
			</span>
		</div>
	</div>
}

func (m KDAWidget) Render(ctx context.Context, w io.Writer) error {
	return m.build().Render(ctx, w)
}

type CSWidget struct {
	CS int

	CSPerMinute float32
}

templ (m CSWidget) build() {
}

func (m CSWidget) Render(ctx context.Context, w io.Writer) error {
	return m.build().Render(ctx, w)
}
